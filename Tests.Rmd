---
title: "Unit tests"
author: "Shyamolina Ghosh and Daniel Reuman"
date: "March 7, 2018"
output: pdf_document
---

<!--Basic setup-->
```{r setup, echo=F}
#Basic setup

#A function needed for caching
source("mtime.R")
```

# Test flexible copula functions
We here test the functions `Corbds`, `Pbds` and `D2bds`.

Set up some test data:
```{r test_copula_function_flexible_data, echo=T}
dl<-seq(from=0.1,by=0.1,to=0.9)
ep<-c(.05,-.03,.02,-.1,-.09,.05,.1,-.08,.05)
vi<-dl+ep
vj<-dl-ep
```

A plot function to use in testing:
```{r plot_vivj,echo=T}
plot_vivj<-function(vi,vj,lb,ub){
plot(vi,vj,col="red",xlim=c(0,1),ylim=c(0,1),asp=1,cex.axis=0.5)
axis(1, at = seq(0, 1, by = 0.1),cex.axis=0.5)
abline(a=2*lb,b=-1,col="blue")
abline(a=2*ub,b=-1,col="green4")
abline(a=0,b=1)
rect(0,0,1,1)
}
```

Test the `Corbds` function:
```{r test_copula_function_flexible_cor, echo=T}
source("CopulaFunctions_flexible.R")
lb=.05
ub=.45
plot_vivj(vi,vj,lb,ub)
h<-Corbds(vi,vj,lb=lb,ub=ub)
inds<-1:4
ht<-sum((vi[inds]-mean(vi))*(vj[inds]-mean(vj)))/((length(vi)-1)*sqrt(var(vi)*var(vj)))

if (abs(h-ht)<1e-12)
{
  print("passed")
}
```

Test the `D2bds` function:
```{r test_copula_function_flexible_D2, echo=T}
source("CopulaFunctions_flexible.R")
lb=.05
ub=.45
h<-D2bds(vi,vj,lb=lb,ub=ub)
if (abs((sum(ep[1:4]^2)/2)-h)<1e-12)
{
  print("passed")
}
```

Test the `Pbds` function:
```{r test_copula_function_flexible_P, echo=T}
source("CopulaFunctions_flexible.R")

vi<-c(vi[3],vi[7],vi[9])
vj<-c(vj[3],vj[7],vj[9])

#Test the case in which the two parallel boundary lines are on the left side 
#of the vi+vj=1 line
lb=0
ub=.45
plot_vivj(vi=vi,vj=vj,lb=lb,ub=ub)
hl<-Pbds(vi,vj,lb=lb,ub=ub)

#plot the step function output - should have one jump at a small distance
#due to the one data point that is between the bound lines
plot(hl$dist_S,hl$S,type="b")

#calculate the area under the curve, compare to what the function returns 
vertices<-unique(hl$dist_S[(hl$dist_S!=0)])
area_S<-(vertices[2]-vertices[1])*1
if (abs(area_S-hl$Au_S)<1e-12)
{
  print("passed")
} else
{
  print("Au_S incorrectly computed")
}
  
#check P stat value for lower tail
if (abs(area_S-hl$Au_Si-hl$abs_res)<1e-12)
{
  print("passed")
} else
{
  print("Error in Pbds, the P stat")
}

#Test the case in which the two parallel boundary lines are on the right side 
#of the vi+vj=1 line
lb=0
ub=.45 
plot_vivj(vi=vi,vj=vj,lb=(1-ub),ub=(1-lb))

#calling P stat for upper tail
hu<-Pbds(vi,vj,lb=(1-ub),ub=(1-lb))

#hl$Au_Si should be the same as hu$Au_Si
if (abs(hl$Au_Si-hu$Au_Si)<1e-12)
{
  print("passed")
}else
{
  print("Error in Pbds, Au_Si")
}

#plot the step fn - should have two jumps
plot(hu$dist_S,hu$S,type="b")

#calculate the area under the curve 
w1<-unique(hu$dist_S[(hu$dist_S!=0)])
w1  #x-coords where the jumps occur, and the max dist
h1<-unique(hu$S)
h1  #y-coords of the above points
area_S<-((w1[2]-w1[1])*(h1[2]-h1[1]))+((w1[3]-w1[2])*(h1[3]-h1[1]))
if (abs(area_S-hu$Au_S)<1e-12)  
{
  print("passed")
} else
{
  print("Au_S incorrectly computed")
}

#P stat value for upper tail
if (abs(area_S-hu$Au_Si-hu$abs_res)<1e-12)
{
  print("passed")
}else
{
  print("P stat incorrectly computed")
}

#Test for the case in which the two parallel boundary lines are on opposite 
#sides of vi+vj=1 line
lb<-0.28
ub<-0.8

#calling P stat for middle section
hm<-Pbds(vi,vj,lb=lb,ub=ub)

#(vi,vj) plot in unit box : middle section
plot_vivj(vi=vi,vj=vj,lb=lb,ub=ub)

#plot the step fn
plot(hm$dist_S,hm$S,type="b")

#calculate the area under the curve 
w1<-unique(hm$dist_S[(hm$dist_S!=0)])
w1  #x-coord where the jump occurs
h1<-unique(hm$S)
h1  #y-coord where the jump occurs
area_S<-((w1[2]-w1[1])*(h1[2]-h1[1]))+((w1[3]-w1[2])*(h1[3]-h1[1]))
if (abs(area_S-hm$Au_S)<1e-12) 
{
  print("passed")
}else
{
  print("Error")
}

#P stat value for middle section
if (abs(area_S-hm$Au_Si-hm$abs_res)<1e-12)
{
  print("passed")
}else
{
  print("Error")
}
```

# Test skewness and third central moment functions

We here test the function `my3cm`, which is an unbiased estimator of the 3rd central moment:
```{r test_myskewness, echo=T, cache=T, cache.extra=list(mtime("SkewnessAnd3CentMom.R"))}
source("SkewnessAnd3CentMom.R")
set.seed(101)

x<-rnorm(100000)
my3cm(x) #should be close to 0

x<-rpois(100000,5)
#should be close to 5, but not necessarily super close
#since 3rd moments are hard to estimate accurately
my3cm(x) 

#see if it appears unbaised
res<-NA*numeric(1000)
for (counter in 1:1000)
{
  x<-rpois(100000,5)
  res[counter]<-my3cm(x) 
}
hist(res)
mean(res)
```

No need to test the accompanying skewness function, since it is such a simple extension of the above.

# Test surrogate functions

Test the `copsurrog2d` function:
```{r test_copsurrog2d, echo=T}
library("VineCopula")
source("copsurrog2d.R")
set.seed(101)

#***basic tests of the function using kendall-preserving surrogates
datcop<-claytonCopula(5,2)
numpts<-1000
m<-rCopula(numpts,datcop)
plot(m[,1],m[,2],type='p',asp=1)
rect(0,0,1,1)

tarcop<-gumbelCopula(3,2)

res<-copsurrog2d(m,tarcop,'kendall',3)
dim(res) 
if (sum(dim(res)[1:2]==dim(m))==2)
{
  print("passed")
} else
{
  print("dim of output is wrong")
}

cor(m[,1],m[,2],method='kendall') #this should be similar to the following 
cor(res[,1,1],res[,2,1],method='kendall')
cor(res[,1,2],res[,2,2],method='kendall')
cor(res[,1,3],res[,2,3],method='kendall')

plot(res[,1,1],res[,2,1],type='p',asp=1) #should look like a Gumbel
rect(0,0,1,1)
BiCopGofTest(res[,1,1],res[,2,1],family=4) #should indicate an acceptable fit; 
                                            #family=4 is Gumbel
BiCopGofTest(res[,1,2],res[,2,2],family=4) #should indicate an acceptable fit
BiCopGofTest(res[,1,3],res[,2,3],family=4) #should indicate an acceptable fit

if (sum(sort(res[,1,1])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,1])==sort(m[,2]))==numpts &&
    sum(sort(res[,1,2])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,2])==sort(m[,2]))==numpts &&
    sum(sort(res[,1,3])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,3])==sort(m[,2]))==numpts)
{
  print("passed")
} else
{
  print("Columns of output of copsurrog should be permutations of the corresponding 
        columns of the input")
}

#***basic tests using spearman preserving surrogates
res<-copsurrog2d(m,tarcop,'spearman',3)
dim(res)
if (sum(dim(res)[1:2]==dim(m))==2)
{
  print("passed")
} else
{
  print("dim of output is wrong")
}

cor(m[,1],m[,2],method='spearman') #this should be similar to the following 
cor(res[,1,1],res[,2,1],method='spearman')
cor(res[,1,2],res[,2,2],method='spearman')
cor(res[,1,3],res[,2,3],method='spearman')

plot(res[,1,1],res[,2,1],type='p',asp=1) #should look like a Gumbel
rect(0,0,1,1)
BiCopGofTest(res[,1,1],res[,2,1],family=4) #should indicate an acceptable fit; 
                                            #family=4 is Gumbel
BiCopGofTest(res[,1,2],res[,2,2],family=4) #should indicate an acceptable fit
BiCopGofTest(res[,1,3],res[,2,3],family=4) #should indicate an acceptable fit

if (sum(sort(res[,1,1])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,1])==sort(m[,2]))==numpts &&
    sum(sort(res[,1,2])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,2])==sort(m[,2]))==numpts &&
    sum(sort(res[,1,3])==sort(m[,1]))==numpts &&
    sum(sort(res[,2,3])==sort(m[,2]))==numpts)
{
  print("passed")
} else
{
  print("Columns of output of copsurrog should be permutations of the corresponding columns of the input")
}
```

Test `copsurrog2d` to see whether changing the copula
markedly influences the distribution
of the spatial mean:
```{r test_copsurrog2d_spatmean, echo=T, cache=T, cache.extra=list(mtime("copsurrog2d.R"),mtime("SkewnessAnd3CentMom.R"))}
set.seed(101)

#make the data
datcop<-rotCopula(claytonCopula(5,2))
d<-rCopula(10000,datcop)
d<-qnorm(d,mean=0,sd=1)

#change the copula
tarcop<-claytonCopula(3,2)
sur<-copsurrog2d(d,tarcop,"kendall",1000)

#see how the skewness of the spatial average
#is affected
source("SkewnessAnd3CentMom.R")
skdat<-myskns(apply(FUN=mean,X=d,MARGIN=1)) #skewness of spatial mean of data
mnres<-apply(FUN=mean,X=sur,MARGIN=c(1,3)) 
sksur<-apply(FUN=myskns,X=mnres,MARGIN=2) #skewnesses of spatial means of surrogate 
                                          #datasets
sum(sksur<skdat)/length(sksur) #skewnesses of surrogs should be less than that of data
range(sksur) #these should mostly be negative
skdat #this should be positive

#now do the same thing but preserve the spearman instead
sur<-copsurrog2d(d,tarcop,"spearman",1000)
skdat<-myskns(apply(FUN=mean,X=d,MARGIN=1))
mnres<-apply(FUN=mean,X=sur,MARGIN=c(1,3))
sksur<-apply(FUN=myskns,X=mnres,MARGIN=2)
sum(sksur<skdat)/length(sksur) #skewnesses of surrogs should be less than that of data
range(sksur) #these should mostly be negative
```

Test the `ncsurrog` function:
```{r test_ncsurrog, echo=T, cache=T, cache.extra=list(mtime("ncsurrog.R"))}
source("ncsurrog.R")
set.seed(103)

#test without NAs
cop<-claytonCopula(5,3)
numpts<-1000
m<-rCopula(numpts,cop)
plot(m[,1],m[,2],type='p',asp=1)
rect(0,0,1,1)
plot(m[,1],m[,3],type='p',asp=1)
rect(0,0,1,1)
res<-ncsurrog(m,"kendall",3)
if (sum(dim(res)==c(1000,3,3))==3)
{
  print("passed")
} else
{
  print("dimension wrong in ncsurrog output")
}

plot(res[,1,1],res[,2,1],type='p',asp=1)
rect(0,0,1,1) #should look like a normal copula
plot(res[,1,1],res[,3,1],type='p',asp=1)
rect(0,0,1,1) #should look like a normal copula

#these should show an adequate fit
ncop<-normalCopula(.5,2)
BiCopGofTest(res[,1,1],res[,2,1],family=1)
BiCopGofTest(res[,1,2],res[,2,2],family=1)
BiCopGofTest(res[,1,3],res[,2,3],family=1)

#test with NAs
m[sample(1:numpts,5),1]<-NA
m[sample(1:numpts,5),2]<-NA
m[sample(1:numpts,5),3]<-NA
res<-ncsurrog(m,"kendall",3)
if (sum(dim(res)==c(1000,3,3))==3)
{
  print("passed")
} else
{
  print("dimension wrong in ncsurrog output")
}

sum(is.na(res[,1,1])) #these should all be 5
sum(is.na(res[,2,1]))
sum(is.na(res[,1,2]))
sum(is.na(res[,2,2]))

plot(res[,1,1],res[,2,1],type='p',asp=1)
rect(0,0,1,1) #should look like a normal copula
plot(res[,1,1],res[,3,1],type='p',asp=1)
rect(0,0,1,1) #should look like a normal copula

#these should show an adequate fit
BiCopGofTest(res[,1,1],res[,2,1],family=1)
BiCopGofTest(res[,1,2],res[,2,2],family=1)
BiCopGofTest(res[,1,3],res[,2,3],family=1)
```

# Tests to model selection tool

We here test the `OurBiCopSelect` function with simulated data.

Data are simulated from a Clayton copula with parameter 8:
```{r get_data_test, echo=T}
source("getcopula.R")
source("OurBiCopSelect.R")
set.seed(101)
cop<-claytonCopula(8,2)
d<-rCopula(1000,cop)
v<-getcopula(d=d,rankon=F,ploton=T) #with real data, rankon should be T
```

Now apply the function:
```{r bivmodselect_test, echo=F, cache=T, cache.extra=list(d,mtime("OurBiCopSelect.R"))}
families<-c(1,3,4,5,13)
BivMS_res_test<-OurBiCopSelect(d[,1],d[,2],families=families,gofnormal=TRUE,status=TRUE)
```

Independence should be rejected (low $p$ value):
```{r echo=T}
BivMS_res_test$IndepTestRes
```

Model selection should support the actual model (Clayton):
```{r echo=T}
BivMS_res_test$InfCritRes
```

The actual model (Clayton) should not be rejected:
```{r echo=T}
BivMS_res_test$GofRes_CvM
BivMS_res_test$GofRes_KS
```

Look at goodness-of-fit results for the normal copulas:
```{r echo=T}
BivMS_res_test$GofRes_Normal_CvM
BivMS_res_test$GofRes_Normal_KS
```

<!--Shya to add headers for other things that need to be tested, and let's discuss before you add the tests themselves-->