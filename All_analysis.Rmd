---
title: "Exploring the importance of a complete statistical description of dependence in ecology and evolution"
author: "Shyamolina Ghosh and Daniel Reuman"
date: "February 8, 2018"
output: 
  html_document:
    fig_caption: yes
    fig_width: 5
    highlight: tango
    keep_tex: yes
    number_sections: yes
    df_print: kable # data frame printing option
fontsize: 11pt
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
seed<-101
families<-c(1,3:6,14)
source("getcopula.R")
source("OurBiCopSelect.R")
```

<!--A function needed for caching-->
```{r echo=F}
mtime <- function(files)
{
  lapply(Sys.glob(files),function(x) X =   
          file.info(x)$mtime)
}
```

Updated on `r Sys.Date()`

# Template analysis

**About the dataset :**  
These data were simulated from a Clayton copula with parameter 8.

**Plot the raw data:**  
```{r load_data_test, echo=F}
#Load your data - should be a data frame with 2 columns. Can contain NAs.
d<-readRDS("Data/givendata.RDS")
plot(d[,1],d[,2],type="p",col="red",xlab=expression(d[1]),ylab=expression(d[2]),cex.lab=1,
     xlim=c(0,1),ylim=c(0,1),asp=1)
rect(0,0,1,1)
```

**Copula plot of the data:**  
```{r rankandplot_test, echo=F}
#convert to a copula and plot
v<-getcopula(d=d,rankon=F,ploton=T) #with real data, rankon should be T
```

**Bivariate copula model selection and goodness of fit pipeline:**  
```{r bivmodselect_test, echo=F, cache=T, cache.extra=list(seed,v,families)}
set.seed(seed)
BivMS_res_test<-OurBiCopSelect(v[,1],v[,2],families=families,gofnormal=FALSE,status=TRUE)
```

```{r}
BivMS_res_test
```

# Results from dataset1 : T. Loecke

**About the dataset :**  
Carbon and nitrogen in soil at many locations across CONUS (Terry to augment this description).

**Plot the raw data:**  
```{r load_data_Loecke, echo=F}
#Load your data - should be a data frame with 2 columns. Can contain NAs.
d<-readRDS("Data/RaCA_soilorganicC_soiltotalN_stocks100cm.RDS")
d<-d[,c("SOCstock100","TSNstock100")]
plot(d[,1],d[,2],type="p",col="red",xlab=expression(d[1]),ylab=expression(d[2]),cex.lab=1)
rect(0,0,1,1)
```

**Copula plot of the data:**  
```{r rankandplot_Loecke, echo=F}
#convert to a copula and plot
v<-getcopula(d=d,rankon=T,ploton=T) #with real data, rankon should be T
```

**Bivariate copula model selection and goodness of fit pipeline:**  
```{r bivmodselect_Loecke, echo=F, cache=T, cache.extra=list(seed,v)}
set.seed(seed)
families_Loecke<-c(1,3:10,13:14,16:20,104,114,204,214)
BivMS_res_Loecke<-OurBiCopSelect(v[,1],v[,2],families=families_Loecke,
                                 gofnormal=FALSE,status=TRUE)
```

```{r}
BivMS_res_Loecke
```

None of the copulas we tried here was a good fit, but some are much 
better than others, and the normal copula is not close to the best. 
So that shows there is non-trivial (i.e., non-normal) copula structure, which is an interesting conclusion. It is more interesting than it would have been to specifically identify a copula that fits, so I am not too concered about our failure to do that.

It looks like the data might be asymmetric about the y=x line, which
might require a special copula to model. What is the significance of this,
biologically?

Strong dependence in the extreme right tails is evident. We could
quantify this, and (probably) show it is significantly more than what one would expect from a null hypothesis of a normal copula with the same kendall as the data. What is the significance, biologically? We could (probably) also show there is much more asymmetry of tail dependence (upper v. lower) than would be expected from a normal-copula null hypothesis.

Probably the most promising next step is to get a function $f(N,C)$ from Amy or Terry (or someone else) which is the expected value of some ecosystem function (or other quantity of interest), supported by a publication. Then calculate its value on all the sites and look at the distribution and calculate, say, its skewness or some other property. Then get surrogate, randomized data with normal copula structure (or some other copula structure - try Clayton because it has the reverse tail dependence). Then calculate the distribution of $f(N,C)$ for each surrogate dataset and its skewness (or other statistic) and compare. I already have code for this (`copsurrog2d.R`). So let's try this. Here is a function:

```{r ecofunc_Loecke, cache=T, cache.extra=list(d,mtime("copsurrog2d.R"))}
#Expected value of some ecosystem function for a 
#soil based on soil N and C
#
#Args
#N    Vector of N values for a bunch of soils
#C    Vector (same length as N) of C values for the same soils
#
#Output
#Expected value of some ecosystem function for those soils (vector of the same length as N and C).
#
ecofunc<-function(N,C)
{
  #right now this is just a placeholder, a real formula and a specific ecosystem function of interest to be specified by Amy and Terry
  return(N+C)
}

source("copsurrog2d.R")
source("SkewnessAnd3CentMom.R")
inds<-which(is.finite(d[,1]) & is.finite(d[,2]))
d<-d[inds,]

#compare to a normal-copula null
cop<-normalCopula(.5,2)
numresamp<-1000
dsur<-copsurrog2d(m=d,targetcop=cop,numsurrog=numresamp)
efval<-myskns(ecofunc(d[,2],d[,1]))

efvalsurN<-NA*numeric(numresamp)
for (counter in 1:numresamp)
{
  efvalsurN[counter]<-myskns(ecofunc(dsur[,2,counter],dsur[,1,counter]))
}
sum(efvalsurN<efval)/numresamp
hist(efvalsurN,50)
points(efval,0,col='red')

#compare to a clayton-copula null
cop<-claytonCopula(.5,2)
numresamp<-1000
dsur<-copsurrog2d(m=d,targetcop=cop,numsurrog=numresamp)
efvalsurC<-NA*numeric(numresamp)
for (counter in 1:numresamp)
{
  efvalsurC[counter]<-myskns(ecofunc(dsur[,2,counter],dsur[,1,counter]))
}
sum(efvalsurC<efval)/numresamp
hist(efvalsurC,50)
points(efval,0,col='red')

#compare to a joe-copula null
cop<-joeCopula(3,2)
numresamp<-1000
dsur<-copsurrog2d(m=d,targetcop=cop,numsurrog=numresamp)
efvalsurJ<-NA*numeric(numresamp)
for (counter in 1:numresamp)
{
  efvalsurJ[counter]<-myskns(ecofunc(dsur[,2,counter],dsur[,1,counter]))
}
sum(efvalsurJ<efval)/numresamp
hist(efvalsurJ,50)
points(efval,0,col='red')
```

