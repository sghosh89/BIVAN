---
title: "Supporting Information"
author: "Shyamolina Ghosh and Daniel Reuman"
date: "February 12, 2018"
geometry: "left=1cm,right=1cm,top=2.5cm,bottom=2.8cm"

output: 
  pdf_document:
    number_sections: yes
    keep_tex: yes
    fig_caption: yes
---

updated on `r Sys.Date()`

<!--Basic setup-->
```{r setup, echo=F}
knitr::opts_chunk$set(echo = TRUE, fig.pos = "H")

library(captioner)
table_nums <- captioner(prefix = "Table")
fig_nums <- captioner(prefix="Figure")

seed<-101
families<-c(1,3:10,13,14,16:20)

#A function needed for caching
mtime <- function(files)
{
  lapply(Sys.glob(files),function(x) X =   
          file.info(x)$mtime)
}

source("getcopula.R")
source("OurBiCopSelect.R")
source("FittingCopula_selective_loc.R")
source("aphid_data_calling.R")
source("plankton_north_sea_data_calling.R")
source("NonParamStat.R")
source("copsurrog2d.R")
source("TestStats_multivar_dataset.R")
```

# Descriptions of data
<!--Each data contributor writes one to a few paragraphs about their data.-->

## Soil C and N data

<!--The raw data look like this:-->
```{r load_data_Loecke, echo=F, fig.cap="Plot of the raw soil C and N data.", fig.height=5, fig.width=5}
d<-readRDS("Data/RaCA_soilorganicC_soiltotalN_stocks100cm.RDS")
d<-d[,c("SOCstock100","TSNstock100")]
fig_nums("soilCNraw",display=F)
plot(d[,1],d[,2],type="p",col="red",xlab="Soil C",ylab="Soil N",cex.lab=1)
```

<!--The copula looks like this:-->
```{r rankandplot_Loecke, echo=F, fig.cap="Copula plot of soil C and N data.",  fig.height=5, fig.width=5}
#convert to a copula and plot
fig_nums("soilCNcop",display=F)
v_CN<-getcopula(d=d,rankon=T,ploton=T) 
```

Carbon and nitrogen in soil at many locations across CONUS (Terry to augment this description). The raw data are shown in `r fig_nums("soilCNraw",display="c")`. The copula is shown in `r fig_nums("soilCNcop",display="c")`.

<!--Shyamolina, let's not put in newpages and other spacing modifications until possibly at the end, once all the content is essentially settled-->

## Aphid data
   * Aphid data contains 3 measurements [count, firstflight, flight-duration] at 11 locations for 20 species and for 35 years.
   * We threw out all locations that had fewer than 30 years data 
   * We use species=10 [Name : "Green spruce aphid"] for aphid-count data 
   * We use species=11 [Name : "Leaf-curling plum aphid"] for aphid-firstflight data   
   
## North Sea plankton data
   * Plankton North sea dataset collects data at 26 locations for 22 species and for 56 years.
   * We threw out all locations that had fewer than 45 years data
   * We use species=16 [Name : "Ceratium_furca"] for Plankton_North_Sea data
   
# Question 1 analyses for each dataset
Recall that question 1 is: Do datasets in ecology and related fields have non-Gausian copula structure? Do they show tail dependence distinct from that of a Gaussian copula? In particular do they show asymmetric tail dependence?

## Details of methods

### Model selection approach


### Non-parametric analysis of tail dependence

<!--Shya to edit this description of the stats. Don't need subsections for each stat.-->
<!--Eventually we will need to add methods on how we use these stats, which is different for multivariate and bivariate data-->
<!--Eventually, for the multivariate data, we will need to demonstrate using a similar analysis to what is in mbsyn, that you can detect asymmetry of tail dependence using these stats - we have done this, but it needs to be adapted-->

```{r stat_image, echo=F}
fig_nums("stat_image",display=F)
```
![schematic diagram for npa of tail dependence](./stat_image.jpg){ width=30%, height=30% }

In a given ranking based copula plot of a dataset within a unit square box the data points are scattered according to their joint-marginal distribution. Say, there are total $n$ number of data points and $vi$ and $vj$ are the ranks of the dataset scaled down by factor $(n+1)$ taken at $(i,j)$ location pair or for $(i,j)$ observables. Now, to calculate our statistic we choose an arbitrary region of the box bounded by two parallel lines [blue line : $vi+vj=2l_{b}$, red line : $vi+vj=2u_{b}$ in `r fig_nums("stat_image",display="c")`] where $(l_{b},u_{b})$ has a range $[0,1]$ with the condition that $u_{b}$ must be greater than $l_{b}$. Now we will demonstrate 3 different type of stats : 

$Cor$, the correlation between the ${n}'$ number of points lying in between those two parallel lines, is given by;

\begin{equation}\label{eq.Cor}
   Cor = \frac{1}{n-1}\sum_{k=1}^{{n}'} \left [ vi(k)-\left<vi\right> \right ] \left[ vj(k)-\left<vj\right> \right ]
\end{equation}

where, $\left<vi\right>$ and $\left<vj\right>$ are the arithmatic mean of $vi$ and $vj$ of $n$ data points within the box, respectively.

We can shift that pair of lines along the diagonal line of the box and can get a sense how the points are spread along the diagonal and how the quantity $Cor$ changes.

For multivariate datasets due to limited number of data points this chosen region is broad, i. e., we measured $Cor$ for $(l_{b}=0,u_{b}=0.5)$ and $(l_{b}=0.5,u_{b}=1)$ and stored as $Corl$ and $Coru$ respectively. If we take their difference then that will tell us which end of the copula is with stronger correlation. A copula with $(Corl-Coru)>0$ should have more lower tail dependence whereas $(Corl-Coru)<0$ indicates more upper tail dependence. Symmetric copula, e. g., (Normal or Frannk) has $Corl = Coru$.

On a second thought, we imagine as if we progress from the diagonal towards the sides of the box with $h$ gradually increasing from $0$ to $h_{max}$, where $h_{max}$ is the half-length of the longer one between two parallel lines. Then we take $S$, the ratio of number of points which are within $h$ distance from the diagonal on both side and the total number of points lie within the shaded region. Now, we want to measure that how much $S$ deviates from the standard $Si$ line when they are plotted against $h$ where $Si$ is the ratio of the area covered by distance $h$ on both side and the area of shaded region. This deviation $P$, representing our statistics to measure tail dependence, is given by;

\begin{equation}\label{eq.P}
   P = \int_0^{h_{max}} \left[ S(h) - Si(h) \right] \,dh
\end{equation}

Like we said before, for multivariate dataset we measure $Pl = P$ for $(l_{b}=0, u_{b}=0.5)$ and $Pu = P$ for $(l_{b}=0.5, u_{b}=1)$ and these $Pl$, $Pu$ represent the lower and upper tail statistic respectively. A copula having $(Pl-Pu)>0$ represents more lower tail dependence whereas a copula with negative $(Pl-Pu)$ represents more upper tail dependence. A copula with equal $Pl$ and $Pu$ value is considered as symmetric with no tail-dependence.

For our third statistic, we imagine the diagonal line of the box as the major axis of the copula. We calculate squared distance of each scattered point from $vi-vj=0$ [the dotted diagonal line in `r fig_nums("stat_image",display="c")`] and then take their average. This mean squared distance (say, $D2$) represents the average width of the copula for that shaded region. Similarly, we calculate $D2l$ and $D2u$ for the lower and upper tail of a copula for multivariate dataset with $(l_{b}=0, u_{b}=0.5)$ and $(l_{b}=0.5, u_{b}=1)$ respectively. If for a given copula $(D2u-D2l)>0$, then it is with more lower tail dependence as the upper-end points are distantly spaced from the long axis of the copula. Conversely, $(D2u-D2l)<0$ means a copula with more upper tail dependence. If $D2l$ and $D2u$ are equal, then the data come from a symmetric copula.

### Stat-testing of Non-parametric analysis (for limited number of datapoints)
```{r stat_testing_plot, echo=F, cache=T, cache.extra=list(seed,mtime("TestStats_multivar_dataset.R"))}
set.seed(seed)

resultsloc<-"./Results/stat_results/stat_testing/"
callfn<-coplist_with_params(spearvals=seq(from=0,to=0.9,by=0.1))
coplist<-callfn$coplist
ncores<-3
res_pt35_rankF<-mclapply(X=coplist,FUN=worker,numpts=35,numsims=100,rank=F,mc.cores=ncores)
res_pt35_rankT<-mclapply(X=coplist,FUN=worker,numpts=35,numsims=100,rank=T,mc.cores=ncores)
res_pt1000_rankF<-mclapply(X=coplist,FUN=worker,numpts=1000,numsims=100,rank=F,mc.cores=ncores)
res_pt1000_rankT<-mclapply(X=coplist,FUN=worker,numpts=1000,numsims=100,rank=T,mc.cores=ncores)
save(res_pt35_rankF,res_pt35_rankT,res_pt1000_rankF,res_pt1000_rankT,file=paste(resultsloc,"StatTestNumericResults.RData",sep=''))

b<-callfn$paramlist
plotter_stat_testing(res_pt35_rankF,"res_pt35_rankF",b)
plotter_stat_testing(res_pt35_rankT,"res_pt35_rankT",b)
plotter_stat_testing(res_pt1000_rankF,"res_pt1000_rankF",b)
plotter_stat_testing(res_pt1000_rankT,"res_pt1000_rankT",b)

```

<!--Now give the plot a number so it can be refered to-->
```{r stat_testing35,echo=F}
fig_nums("stat_testing35",display=F)
```
![stat_testing_results_datapt_35](./Results/stat_results/stat_testing/res_pt35_rankT.pdf)

```{r stat_testing1000,echo=F}
fig_nums("stat_testing1000",display=F)
```
![stat_testing_results_datapt_1000](./Results/stat_results/stat_testing/res_pt1000_rankT.pdf)


## Soil C and N data

### Model selection approach
<!--This does the computations for this section-->
```{r bivmodselect_Loecke, echo=F, cache=T, cache.extra=list(seed,v_CN,mtime("OurBiCopSelect.R"))}
set.seed(seed)
families_Loecke<-c(1,3:10,13:14,16:20) 
BivMS_res_Loecke<-OurBiCopSelect(u1=v_CN[,1],u2=v_CN[,2],families=families_Loecke,level=0.05,AICBIC="AIC",numBSsmall=100,pthresh=0.2,numBSlarge=1000,gofnormal=F,status=F)
```
The test of indepedence gave $p=$ `r BivMS_res_Loecke$IndepTestRes`. We fitted several copulas
and got AIC values and upper- and lower-tail dependency estimates based on the fitted copulas (`r table_nums("soilCNfit",display="c")`). The table shows that several copulas are much better supported (higher AIC and BIC weights) than the Gaussian copula, answering the first part of question 1 for these data.

<!--Display model selection results in a table-->
```{r soilCNfit,echo=F}
h<-BivMS_res_Loecke$InfCritRes[,c("copname","AICw","BICw","LTdep","UTdep")]
table_nums("soilCNfit",display=F)
knitr::kable(h, caption = "Fitting info for soil C and N dataset. Here and henceforth copula names are abbreviated as: N=normal (Gaussian); C=Clayton; G=Gumbel; F=Frank; J=Joe; SC=Survival Clayton; SG=Survival Gumbel; SJ=Survival Joe. An S in front of one of the copulas BB1, BB6, BB7, BB8 indicates the survival version of that copula (rotation by 180 degrees).")
```

The model-averaged (AIC weights used for model averaging) lower-tail dependence statistic was `r BivMS_res_Loecke$relLTdep_AICw` and the model-averaged upper-tail dependence statistic was `r BivMS_res_Loecke$relUTdep_AICw`. These values are distinct from what a Gaussian copula would give (i.e., 0), answering the second part of question 1 for these data. Furthermore, the difference of these two quantities (lower minus upper), `r BivMS_res_Loecke$relLTdep_AICw-BivMS_res_Loecke$relUTdep_AICw`, was different from 0, answering the third part of question 1. 

Although these results do convincingly show non-Gaussian copula structure, we should take the tail dependence results with a grain of salt because even the lowest-AIC copula was a poor fit, giving $p$-value `r BivMS_res_Loecke$GofRes_CvM` in the Cramer-von Mises-based test of the goodness of its fit, and $p$-value `r BivMS_res_Loecke$GofRes_KS` in the Kolmogorov-Smirnov-based test of the goodness of fit. The next section looks at tail dependence in a non-parametric way.

### Non-parametric analysis of tail dependence
<!--Do the intensive part of the analysis, calculating stats on the data and surrogates-->
```{r stat_soilCN_graphic_approach, echo=F, cache=T, cache.extra=list(seed,v_CN,mtime("CopulaFunctions_flexible.R"),mtime("copsurrog2d.R"))}
set.seed(seed) 

#utility function for calculating all the stats we want
calcstats<-function(v,f,nm)
{
  #calculate the stats
  res<-c()
  for (lbd in seq(from=0,to=0.9,by=0.1))
  {
    res<-c(res,f(v[,1],v[,2],lbd,lbd+.1))
  }
  
  #name the result vector
  h<-paste(nm,c(seq(from=0,to=0.9,by=0.1)),"to",
                    c(seq(from=0,to=0.9,by=0.1)+.1),sep='')
  h<-gsub(".","p",h,fixed=T)
  names(res)<-h
    
  return(res)
}

#Do the kendall surrogates
cop<-normalCopula(.5,2)
numsurrog<-1000
surv_K<-copsurrog2d(v_CN,cop,"kendall",numsurrog)

#Do the spearman surrogates
surv_S<-copsurrog2d(v_CN,cop,"spearman",numsurrog)

#utility function for calculating fractions of surrogates 
#with a stat smaller than that of data, i.e., fraction of 
#surrogates for which the stat value on the data is bigger
fracwork<-function(dvals,surrvals)
{
  frac<-NA*numeric(length(dvals))
  names(frac)<-names(dvals)
  for (counter in 1:length(frac))
  {
    frac[counter]<-sum(surrvals[counter,]<dvals[counter])
  }
  return(frac)
}

#now work with the correlation stats
corstats_d<-calcstats(v_CN,Corbds,"Cor")
corstats_K<-apply(FUN=calcstats,X=surv_K,MARGIN=3,f=Corbds,nm="Cor")
corstats_frac_K<-fracwork(corstats_d,corstats_K)

corlmcoru_d<-unname(corstats_d[1]-corstats_d[length(corstats_d)])
corlmcoru_K<-corstats_K[1,]-corstats_K[length(corstats_d),]
corlmcoru_frac_K<-sum(corlmcoru_K<corlmcoru_d)
corstats_K<-apply(FUN=quantile,X=corstats_K,MARGIN=1,prob=c(.005,0.25,.975,.995))

corstats_S<-apply(FUN=calcstats,X=surv_S,MARGIN=3,f=Corbds,nm="Cor")
corstats_frac_S<-fracwork(corstats_d,corstats_S)

corlmcoru_S<-corstats_S[1,]-corstats_S[length(corlmcoru_d),]
corlmcoru_frac_S<-sum(corlmcoru_S<corlmcoru_d)
corstats_S<-apply(FUN=quantile,X=corstats_S,MARGIN=1,prob=c(.005,0.25,.975,.995))

#now work with the P stats
Pbds_wrap<-function(vi,vj,lb,ub)
{
  return(Pbds(vi,vj,lb,ub)$abs_res)
}

Pstats_d<-calcstats(v_CN,Pbds_wrap,"P")
Pstats_K<-apply(FUN=calcstats,X=surv_K,MARGIN=3,f=Pbds_wrap,nm="P")
Pstats_frac_K<-fracwork(Pstats_d,Pstats_K)

PlmPu_d<-unname(Pstats_d[1]-Pstats_d[length(Pstats_d)])
PlmPu_K<-Pstats_K[1,]-Pstats_K[length(Pstats_d),]
PlmPu_frac_K<-sum(PlmPu_K<PlmPu_d)
Pstats_K<-apply(FUN=quantile,X=Pstats_K,MARGIN=1,prob=c(.005,0.25,.975,.995))

Pstats_S<-apply(FUN=calcstats,X=surv_S,MARGIN=3,f=Pbds_wrap,nm="P")
Pstats_frac_S<-fracwork(Pstats_d,Pstats_S)

PlmPu_S<-Pstats_S[1,]-Pstats_S[length(Pstats_d),]
PlmPu_frac_S<-sum(PlmPu_S<PlmPu_d)
Pstats_S<-apply(FUN=quantile,X=Pstats_S,MARGIN=1,prob=c(.005,0.25,.975,.995))

#now work with the D2 stats
D2stats_d<-calcstats(v_CN,D2bds,"Dtwo")
D2stats_K<-apply(FUN=calcstats,X=surv_K,MARGIN=3,f=D2bds,nm="Dtwo")
D2stats_frac_K<-fracwork(D2stats_d,D2stats_K)

D2umD2l_d<-D2stats_d[length(D2stats_d)]-D2stats_d[1]
D2umD2l_K<-D2stats_K[length(D2stats_d),]-D2stats_K[1,]
D2umD2l_frac_K<-sum(D2umD2l_K<D2umD2l_d)
D2stats_K<-apply(FUN=quantile,X=D2stats_K,MARGIN=1,prob=c(.005,0.25,.975,.995))

D2stats_S<-apply(FUN=calcstats,X=surv_S,MARGIN=3,f=D2bds,nm="Dtwo")
D2stats_frac_S<-fracwork(D2stats_d,D2stats_S)

D2umD2l_S<-D2stats_S[length(D2stats_d),]-D2stats_S[1,]
D2umD2l_frac_S<-sum(D2umD2l_S<D2umD2l_d)
D2stats_S<-apply(FUN=quantile,X=D2stats_S,MARGIN=1,prob=c(.005,0.25,.975,.995))
```

<!--Now create the plot and save it to the results folder-->
```{r plot_soilCN_graphic_approach, echo=F}
x<-seq(from=0.05,to=0.95,by=0.1)
xlimits<-c(0,1)

#plotting layout, units inches
xht<-0.5
ywd<-0.5
titleht<-.25
panht<-1.5
panwd<-3
gap<-.05
totwd<-ywd+2*panwd+2*gap
totht<-xht+3*panht+3*gap+titleht
pdf(file="./Results/stat_results/stat_soilCN/CNdata_NonparamTailDep.pdf",width=totwd,height=totht)
  
#plot kendall results on the left panels, spearman on right,
#cor in top panels, then P, then D2 on bottom panels

#kendall, cor
par(fig=c(ywd/totwd,
          (ywd+panwd)/totwd,
          (xht+2*panht+2*gap)/totht,
          (xht+3*panht+2*gap)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25)
ylimits_cor<-range(corstats_d,corstats_K,corstats_K)
ylimits_cor[2]<-ylimits_cor[2]+.3*diff(ylimits_cor)
plot(x,corstats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_cor,
     xaxt='n')
mtext(side=3,line=0,text="Kendall-preserving surrogates")
mtext(side=2,line=1,text="Partial correlation")
axis(side=1,labels=F)
lines(x,corstats_K[1,],type='l',lty='dotted')
lines(x,corstats_K[2,],type='l',lty='dashed')
lines(x,corstats_K[3,],type='l',lty='dashed')
lines(x,corstats_K[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_cor[1],labels='A',cex=1.5,adj=c(.5,0))
fracplot<-function(fracs,ylims)
{
  for (counter in 1:length(fracs))
  {
    ptxt<-''
    if (fracs[counter]>.975*numsurrog)
    {
      ptxt<-paste(">",fracs[counter],sep='')
    } 
    if (fracs[counter]<.025*numsurrog)
    {
      ptxt<-paste("<",numsurrog-fracs[counter],sep='')
    }
    yht<-ylims[2]-.1*diff(ylims)
    text(x[counter],yht,ptxt,adj=c(0.5,.5),cex=0.5,srt=90)
  }
}
fracplot(corstats_frac_K,ylimits_cor)
vlineplot<-function(x,ylims)
{
  for (counter in 1:length(x))
  {
    lines(rep(x[counter]-(x[2]-x[1])/2,2),ylims,type='l',lty='dotted')
  }
  lines(rep(x[length(x)]+(x[2]-x[1])/2,2),ylims,type='l',lty='dotted')
}
vlineplot(x,ylimits_cor)

#spearman, cor
par(fig=c((ywd+panwd+gap)/totwd,
          (ywd+2*panwd+gap)/totwd,
          (xht+2*panht+2*gap)/totht,
          (xht+3*panht+2*gap)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25,new=T)
plot(x,corstats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_cor,
     xaxt='n',yaxt='n')
mtext(side=3,line=0,text="Spearman-preserving surrogates")
axis(side=1,labels=F)
axis(side=2,labels=F)
lines(x,corstats_S[1,],type='l',lty='dotted')
lines(x,corstats_S[2,],type='l',lty='dashed')
lines(x,corstats_S[3,],type='l',lty='dashed')
lines(x,corstats_S[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_cor[1],labels='B',cex=1.5,adj=c(.5,0))
fracplot(corstats_frac_S,ylimits_cor)
vlineplot(x,ylimits_cor)

#kendall, P
par(fig=c(ywd/totwd,
          (ywd+panwd)/totwd,
          (xht+panht+gap)/totht,
          (xht+2*panht+gap)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25,new=T)
ylimits_D2<-range(D2stats_d,D2stats_K,D2stats_K)
ylimits_D2[2]<-ylimits_D2[2]+.3*diff(ylimits_D2)
ylimits_P<-range(Pstats_d,Pstats_K,Pstats_K)
ylimits_P[2]<-ylimits_P[2]+.3*diff(ylimits_P)
plot(x,Pstats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_P,xaxt='n')
axis(side=1,labels=F)
mtext(side=2,line=1,text="P")
lines(x,Pstats_K[1,],type='l',lty='dotted')
lines(x,Pstats_K[2,],type='l',lty='dashed')
lines(x,Pstats_K[3,],type='l',lty='dashed')
lines(x,Pstats_K[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_P[1],labels='C',cex=1.5,adj=c(.5,0))
fracplot(Pstats_frac_K,ylimits_P)
vlineplot(x,ylimits_P)

#spearman, p
par(fig=c((ywd+panwd+gap)/totwd,
          (ywd+2*panwd+gap)/totwd,
          (xht+panht+gap)/totht,
          (xht+2*panht+gap)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25,new=T)
plot(x,Pstats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_P,
     xaxt='n',yaxt='n')
axis(side=1,labels=F)
axis(side=2,labels=F)
lines(x,Pstats_S[1,],type='l',lty='dotted')
lines(x,Pstats_S[2,],type='l',lty='dashed')
lines(x,Pstats_S[3,],type='l',lty='dashed')
lines(x,Pstats_S[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_P[1],labels='D',cex=1.5,adj=c(.5,0))
fracplot(Pstats_frac_S,ylimits_P)
vlineplot(x,ylimits_P)

#kendall, D2
par(fig=c(ywd/totwd,
          (ywd+panwd)/totwd,
          (xht)/totht,
          (xht+panht)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25,new=T)
plot(x,D2stats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_D2)
mtext(side=1,line=1,text="Diagonal slice")
mtext(side=2,line=1,text=expression(D[2]))
axis(side=1,labels=F)
lines(x,D2stats_K[1,],type='l',lty='dotted')
lines(x,D2stats_K[2,],type='l',lty='dashed')
lines(x,D2stats_K[3,],type='l',lty='dashed')
lines(x,D2stats_K[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_D2[1],labels='E',cex=1.5,adj=c(.5,0))
fracplot(D2stats_frac_K,ylimits_D2)
vlineplot(x,ylimits_D2)

#spearman, P
par(fig=c((ywd+panwd+gap)/totwd,
          (ywd+2*panwd+gap)/totwd,
          (xht)/totht,
          (xht+panht)/totht),
    mai=c(0,0,0,0),mgp=c(3,.15,0),tcl=-.25,new=T)
plot(x,D2stats_d,type='l',col="red",xlim=xlimits,ylim=ylimits_D2,
     yaxt='n')
mtext(side=1,line=1,text="Diagonal slice")
axis(side=1,labels=F)
axis(side=2,labels=F)
lines(x,D2stats_S[1,],type='l',lty='dotted')
lines(x,D2stats_S[2,],type='l',lty='dashed')
lines(x,D2stats_S[3,],type='l',lty='dashed')
lines(x,D2stats_S[4,],type='l',lty='dotted')
text(xlimits[1],ylimits_D2[1],labels='F',cex=1.5,adj=c(.5,0))
fracplot(D2stats_frac_S,ylimits_D2)
vlineplot(x,ylimits_D2)

dev.off()
```

As described in Methods, each of our statistics, as computed for the 
ranges $0-0.1$, $0.1-0.2$, ..., $0.9-1$, was compared to the distributions 
of values of the same statistic with the same ranges computed on 1000 normal-copula 
surrogate datasets with similar Kendall or Spearman correlations, in different 
runs (`r fig_nums("soilCN_nonparam",display="c")`). Because the correlation 
used in the Cor statistic is the Spearman correlation, Spearman-preserving surrogates
should be used, so the top-left panel of `r fig_nums("soilCN_nonparam",display="c")`
should be ignored (DAN: need to fix this later). Results indicate that tail dependence of 
data is stronger in both the lower and upper tails than would be expected under a 
null hypothesis of a normal copula. The dependence between C and N is also 
weaker in the middle of both marginal distributions
than would be expected based on a normal-copula null model.

<!--Now give the plot a number so it can be refered to-->
```{r show_plot_soildCN,echo=F}
fig_nums("soilCN_nonparam",display=F)
```
![Nonparametric tests for tail dependence and other deviations from a normal copula for soil C and N data. As described in Methods, each statistic was computed on the data using the ranges $0-0.1$, $0.1-0.2$, ..., $0.9-1$ (red lines), and was also computed using the same ranges for 1000 normal-copula surrogate datasets (dashed lines show 0.025 and 0.975 quantiles of these results and dotted lines show 0.005 and 0.995 quantiles).  When red lines were outside dashed lines, text at the top of plots indicates how many surrogate values the data value was less than or greater than.](./Results/stat_results/stat_soilCN/CNdata_NonparamTailDep.pdf)

We also tested statistically for asymmetry of tail dependence, which seems visible in `r table_nums("soilCNcop",display="c")`. 
Results (`r table_nums("soilCN_asym",display="c")`) show that upper-tail dependence was, indeed, significantly stronger than lower-tail dependence in these data.

<!--Now make and display a table, this one about asymmetry of tail dependence-->
```{r plot_soilCN_asymmtry_taildep, echo=F}
atdres<-data.frame(Statistic=c("Corl-Coru","Pl-Pu","D2u-D2l"),
                   Kendall=rep("",3),
                   Spearman=rep("",3),stringsAsFactors = F)
fractxt<-function(fracval)
{
  ptxt<-''
  if (fracval>.5*numsurrog)
  {
    ptxt<-paste(">",fracval,sep='')
  } 
  if (fracval<=.5*numsurrog)
  {
    ptxt<-paste("<",numsurrog-fracval,sep='')
  }
  return(ptxt)
}
atdres[1,2]<-fractxt(corlmcoru_frac_K)
atdres[1,3]<-fractxt(corlmcoru_frac_S)
atdres[2,2]<-fractxt(PlmPu_frac_K)
atdres[2,3]<-fractxt(PlmPu_frac_S)
atdres[3,2]<-fractxt(D2umD2l_frac_K)
atdres[3,3]<-fractxt(D2umD2l_frac_S)

table_nums("soilCN_asym",display=F)
knitr::kable(atdres, caption = "Results for tests of whether asymmetry of tail dependence is significant compared to a normal-copula null hypothesis. Three statistics are listed in the left column that measured asymmetry of tail dependence by comparing the ranges $0-0.1$ and $0.9-1$ (Methods). One thousand Kendall-preserving and 1000 Spearman-preserving surrogates were created, and the same statistics were computed for the surrogates. A table entry $<N$ indicates the value of the given statistic on the data was less than its value on $N$ of the surrogates.")
```

## Aphid abundance data 
<!--Add common and species name to header-->

### Model selection approach

```{r read_aphid_data, echo=F}
# Aphid raw data for count
d0_count<-as.matrix(read.csv("./Data/Aphid_data/APHID_DATA_RAW/aphidtscount141117.csv",header=F))
data_aphid_count<-d_allsp_data(d0_count)     
 
# Aphid raw data for first flight
d0_firstflight<-as.matrix(read.csv("./Data/Aphid_data/APHID_DATA_RAW/aphidtsfirstflight141117.csv",header=F))
data_aphid_ff<-d_allsp_data(d0_firstflight) 

# Aphid raw data for flight duration   
#d0_flightduration<-as.matrix(read.csv("./Data/Aphid_data/APHID_DATA_RAW/aphidtsflightduration141117.csv",header=F))

```

```{r RES_aphid_count, echo=F, cache=T, cache.extra=list(seed,data_aphid_count)}
set.seed(seed)
#cat(paste("start-time: ",Sys.time(),"\n")) 
RES_aphid_count<-RES_single_sp(d_allsp=data_aphid_count,sp=10,families=c(1,3:10,13,14,16:20),level=0.05,data_pt_thrs=30)
#cat(paste("stop-time: ",Sys.time(),"\n"))
resloc<-"./Results/fitting_results/"
saveRDS(RES_aphid_count,paste(resloc,file="AphidCopulaFit_selecloc_count_species_10.RDS",sep=""))
```

```{r read_RES_aphid_count, echo=F}
RES_aphid_count<-readRDS("./Results/fitting_results/AphidCopulaFit_selecloc_count_species_10.RDS")
```

\newpage

```{r count_bestcop,echo=F,results="asis"}
#library(pander)
#pander(best_cop_LTdep, caption = "Hello caption!")
#knitr::kable(RES_aphid_count$info_ord_copname[,,1],format="latex",longtable=F,caption = "Aphid_count : Best fit copula family for each selective location pair")

table_nums("count_bestcop",display=F)
knitr::kable(RES_aphid_count$info_ord_copname[,,1],caption = "Aphid_count : Best fit copula family for each selective location pair")
```

```{r count_AICw,echo=F,results="asis"}
table_nums("count_AICw",display=F)
knitr::kable(RES_aphid_count$info_ord_AICw[,,1], caption = "Aphid_count : AICw for best fit copula family for each selective location pair")
```

```{r count_LTdep,echo=F,results="asis"}
table_nums("count_LTdep",display=F)
knitr::kable(RES_aphid_count$info_ord_LTdep[,,1], caption = "Aphid_count : Lower Tail dependence for best fit copula family for each selective location pair")
```

```{r count_UTdep,echo=F,results="asis"}
table_nums("count_UTdep",display=F)
knitr::kable(RES_aphid_count$info_ord_UTdep[,,1], caption = "Aphid_count : Upper Tail dependence for best fit copula family for each selective location pair")
```

```{r count_LTdep_AICw,echo=F,results="asis"}
table_nums("count_LTdep_AICw",display=F)
knitr::kable(RES_aphid_count$LTdep_AICw,caption = "Aphid_count : Lower Tail dependence statistic for best fit copula family for each selective location pair")
```

```{r count_UTdep_AICw,echo=F,results="asis"}
table_nums("count_UTdep_AICw",display=F)
knitr::kable(RES_aphid_count$UTdep_AICw,caption = "Aphid_count : Upper Tail dependence statistic for best fit copula family for each selective location pair")

```

```{r count_LTmUT,echo=F,results="asis"}
table_nums("count_LTmUT",display=F)
knitr::kable(round(RES_aphid_count$LTdep_AICw-RES_aphid_count$UTdep_AICw,5),caption = "Aphid_count : Lower Tail - Upper Tail dependence statistic for best fit copula family for each of the selective location pair")
```

```{r count_p_CvM,echo=F,results="asis"}
table_nums("count_p_CvM",display=F)
knitr::kable(RES_aphid_count$gfc_p_CvM, caption = "Aphid_count : p-values (Cramer-von Mises-based test) for lowest AIC based best fit copula")
```

```{r count_p_KS,echo=F,results="asis"}
table_nums("count_p_KS",display=F)
knitr::kable(RES_aphid_count$gfc_p_KS,caption = "Aphid_count : p-values (Kolmogorov-Smirnov-based test) for lowest AIC based best fit copula")
```

`r table_nums("count_bestcop",display="c")` shows that several copulas are much better supported than the Gaussian copula, answering the first part of question 1 for these data.
The model-averaged (using AIC) lower-tail dependence statistic and the model-averaged (again, AIC based) upper-tail dependence statistic are presented in `r table_nums("count_LTdep_AICw",display="c")` and `r table_nums("count_UTdep_AICw",display="c")` respectively, and these values are distinct from what a Gaussian copula would give (i.e., 0), answering the second part of question 1 for these data. Furthermore, the difference of these two quantities (lower minus upper) in `r table_nums("count_LTmUT",display="c")` indicates it is different from 0 for most of the locations, answering the third part of question 1. 

These results do convincingly show non-Gaussian copula structure, having **`r sum((RES_aphid_count$LTdep_AICw-RES_aphid_count$UTdep_AICw)>0,na.rm=T)`** out of **`r (dim(RES_aphid_count$gfc_p_CvM)[1]^2-dim(RES_aphid_count$gfc_p_CvM)[1])-RES_aphid_count$num_indep_loc_pair`** location pair with greater lower tail dependence. Our fitting results are supported by the lowest-AIC copula *p*-value in the Cramer-von Mises-based test [`r table_nums("count_p_CvM",display="c")`] of the goodness of its fit, and in the Kolmogorov-Smirnov-based test [`r table_nums("count_p_KS",display="c")`] of the goodness of fit.

The next section looks at tail dependence in a non-parametric way.

### Non-paramtric analysis of tail dependence

```{r stat_aphid_count, echo=F, cache=T, cache.extra=list(seed,data_aphid_count)}
set.seed(seed) 
resloc<-"./Results/stat_results/stat_aphid_count/"

sp<-10
good_loc <- good_loclist(d_allsp=data_aphid_count,sp=sp,data_pt_thrs=30)
longs<-c(-4.567,0.57,-3.069,-3.312,-2.637,-1.682,-2.763,-0.356,-3.454,0.427,0.939)
lats<-c(55.477,52.26,56.457,55.949,52.125,55.213,53.854,51.807,50.628,51.733,51.185)

stat_aphid_count<-multcall(d_allsp=data_aphid_count,sp=sp,lats=lats,longs=longs,pfname=paste(resloc,"Sp_",sp,sep=''),good_loc=good_loc)
saveRDS(stat_aphid_count,paste(resloc,file="stat_aphid_count_sp_10.RDS",sep='')) 
```

```{r read_stat_aphid_count,echo=F}
stat_aphid_count<-readRDS("./Results/stat_results/stat_aphid_count/stat_aphid_count_sp_10.RDS")
```

```{r count_resamp,echo=F,results="asis"}
table_nums("count_resamp",display=F)
knitr::kable(stat_aphid_count$numericdf, caption = "Aphid_count : resampling result for stat indicating lower tail dependence")
```

```{r count_allcop,echo=F}
fig_nums("count_allcop",display=F)
```
![copula plot for aphid-count](./Results/stat_results/stat_aphid_count/Sp_10_AllCops.pdf)

```{r count_spear,echo=F}
fig_nums("count_spear",display=F)
```
![Plot for aphid-count : Spearman vs. Distance](./Results/stat_results/stat_aphid_count/Sp_10_Spearman_vs_D.pdf){ width=50%, height=50% }

```{r count_kend,echo=F}
fig_nums("count_kend",display=F)
```
![Plot for aphid-count : Kendall vs. Distance](./Results/stat_results/stat_aphid_count/Sp_10_Kendall_vs_D.pdf){ width=50%, height=50% }

```{r count_Corl-Coru,echo=F}
fig_nums("count_Corl-Coru",display=F)
```
![Corl-Coru vs. Distance plot for aphid-count showing lower tail dependence](./Results/stat_results/stat_aphid_count/Sp_10_Corl-Coru_vs_D.pdf){ width=50%, height=50% }

```{r count_Pl-Pu,echo=F}
fig_nums("count_Pl-Pu",display=F)
```
![Pl-Pu vs. Distance plot for aphid-count showing lower tail dependence](./Results/stat_results/stat_aphid_count/Sp_10_Pl-Pu_vs_D.pdf){ width=50%, height=50% }

```{r count_D2u-D2l,echo=F}
fig_nums("count_D2u-D2l",display=F)
```
![D2u-D2l vs. Distance plot for aphid-count showing lower tail dependence](./Results/stat_results/stat_aphid_count/Sp_10_D2u-D2l_vs_D.pdf){ width=50%, height=50% }

<!--
```{r, echo=F,out.width = "8cm", out.height= "8cm", out.caption="adhjk"}
knitr::include_graphics("./Results/stat_results/stat_aphid_count/Sp_10_Spearman_vs_D.pdf")
knitr::include_graphics("./Results/stat_results/stat_aphid_count/Sp_10_Kendall_vs_D.pdf")
```
-->

## Aphid first flight data
<!--Add species common name and scientific name to header-->

### Model selection approach

```{r RES_aphid_ff, echo=F, cache=T, cache.extra=list(seed,data_aphid_ff)} 
set.seed(seed)
#cat(paste("start-time: ",Sys.time(),"\n"))
RES_aphid_ff<-RES_single_sp(d_allsp=data_aphid_ff,sp=11,families=c(1,3:10,13,14,16:20),level=0.05,data_pt_thrs=30)
#cat(paste("stop-time: ",Sys.time(),"\n")) 
resloc<-"./Results/fitting_results/"
saveRDS(RES_aphid_ff,paste(resloc,file="AphidCopulaFit_selecloc_firstflight_species_11.RDS",sep=""))
```

```{r read_RES_aphid_ff,echo=F}
RES_aphid_ff<-readRDS("./Results/fitting_results/AphidCopulaFit_selecloc_firstflight_species_11.RDS")
```

\newpage

```{r ff_bestcop,echo=F,results="asis"}
table_nums("ff_bestcop",display=F)
knitr::kable(RES_aphid_ff$info_ord_copname[,,1], caption = "Aphid_firstflight : Best fit copula family for each selective location pair")
```

```{r ff_AICw,echo=F,results="asis"}
table_nums("ff_AICw",display=F)
knitr::kable(RES_aphid_ff$info_ord_AICw[,,1], caption = "Aphid_firstflight : AICw for best fit copula family for each selective location pair")
```

```{r ff_LTdep,echo=F,results="asis"}
table_nums("ff_LTdep",display=F)
knitr::kable(RES_aphid_ff$info_ord_LTdep[,,1], caption = "Aphid_firstflight : Lower Tail dependence for best fit copula family for each selective location pair")
```

```{r ff_UTdep,echo=F,results="asis"}
table_nums("ff_UTdep",display=F)
knitr::kable(RES_aphid_ff$info_ord_UTdep[,,1], caption = "Aphid_firstflight : Upper Tail dependence for best fit copula family for each selective location pair")
```

```{r ff_LTdep_AICw,echo=F,results="asis"}
table_nums("ff_LTdep_AICw",display=F)
knitr::kable(RES_aphid_ff$LTdep_AICw, caption = "Aphid_firstflight : Lower Tail dependence statistic for best fit copula family for each selective location pair")
```

```{r ff_UTdep_AICw,echo=F,results="asis"}
table_nums("ff_UTdep_AICw",display=F)
knitr::kable(RES_aphid_ff$UTdep_AICw, caption = "Aphid_firstflight : Upper Tail dependence statistic for best fit copula family for each selective location pair")
```

```{r ff_LTmUT,echo=F,results="asis"}
table_nums("ff_LTmUT",display=F)
knitr::kable(round(RES_aphid_ff$LTdep_AICw-RES_aphid_ff$UTdep_AICw,5), caption = "Aphid_firstflight : Lower Tail - Upper Tail dependence statistic for best fit copula family for each of the selective location pair")
```

```{r ff_p_CvM,echo=F,results="asis"}
table_nums("ff_p_CvM",display=F)
knitr::kable(RES_aphid_ff$gfc_p_CvM, caption = "Aphid_firstflight : p-values (Cramer-von Mises-based test) for lowest AIC based best fit copula")
```

```{r ff_p_KS,echo=F,results="asis"}
table_nums("ff_p_KS",display=F)
knitr::kable(RES_aphid_ff$gfc_p_KS, caption = "Aphid_firstflight : p-values (Kolmogorov-Smirnov-based test) for lowest AIC based best fit copula")
```

`r table_nums("ff_bestcop",display="c")`  shows that several copulas are much better supported than the Gaussian copula, answering the first part of question 1 for these data.
The model-averaged (using AIC) lower-tail dependence statistic and the model-averaged (again, AIC based) upper-tail dependence statistic are presented in `r table_nums("ff_LTdep_AICw",display="c")` and `r table_nums("ff_UTdep_AICw",display="c")` respectively, and these values are distinct from what a Gaussian copula would give (i.e., 0), answering the second part of question 1 for these data. Furthermore, the difference of these two quantities (lower minus upper) in `r table_nums("ff_LTmUT",display="c")` indicates it is different from 0 for most of the locations, answering the third part of question 1. 

These results do convincingly show non-Gaussian copula structure, having **`r sum((RES_aphid_ff$LTdep_AICw-RES_aphid_ff$UTdep_AICw)<0,na.rm=T)`** out of **`r (dim(RES_aphid_ff$gfc_p_CvM)[1]^2-dim(RES_aphid_ff$gfc_p_CvM)[1])-RES_aphid_ff$num_indep_loc_pair`** location pair more upper tail dependence. Our fitting results are supported by the lowest-AIC copula *p*-value in the Cramer-von Mises-based test [`r table_nums("ff_p_CvM",display="c")`] of the goodness of its fit, and in the Kolmogorov-Smirnov-based test [`r table_nums("ff_p_KS",display="c")`] of the goodness of fit.

### Non-parametric analysis of tail dependence

```{r stat_aphid_ff, echo=F, cache=T, cache.extra=list(seed,data_aphid_ff)}
set.seed(seed)
resloc<-"./Results/stat_results/stat_aphid_ff/"

sp<-11
good_loc<-good_loclist(d_allsp=data_aphid_ff,sp=sp,data_pt_thrs=30)
longs<-c(-4.567,0.57,-3.069,-3.312,-2.637,-1.682,-2.763,-0.356,-3.454,0.427,0.939)
lats<-c(55.477,52.26,56.457,55.949,52.125,55.213,53.854,51.807,50.628,51.733,51.185)

stat_aphid_ff<-multcall(d_allsp=data_aphid_ff,sp=sp,lats=lats,longs=longs,pfname=paste(resloc,"Sp_",sp,sep=''),good_loc=good_loc) 
saveRDS(stat_aphid_ff,paste(resloc,file="stat_aphid_ff_sp_11.RDS",sep='')) 
```

```{r read_stat_aphid_ff,echo=F}
stat_aphid_ff<-readRDS("./Results/stat_results/stat_aphid_ff/stat_aphid_ff_sp_11.RDS")
```

```{r ff_resamp,echo=F,results="asis"}
table_nums("ff_resamp",display=F)
knitr::kable(stat_aphid_ff$numericdf, caption = "Aphid_firstflight : resampling result for stat indicating upper tail dependence")
```

```{r ff_allcop,echo=F}
fig_nums("ff_allcop",display=F)
```
![copula plot for aphid-firstflight](./Results/stat_results/stat_aphid_ff/Sp_11_AllCops.pdf)

```{r ff_spear,echo=F}
fig_nums("ff_spear",display=F)
```
![Plot for aphid-firstflight : Spearman vs. Distance](./Results/stat_results/stat_aphid_ff/Sp_11_Spearman_vs_D.pdf){ width=50%, height=50% }

```{r ff_kend,echo=F}
fig_nums("ff_kend",display=F)
```
![Plot for aphid-firstflight : Kendall vs. Distance](./Results/stat_results/stat_aphid_ff/Sp_11_Kendall_vs_D.pdf){ width=50%, height=50% }

```{r ff_Corl-Coru,echo=F}
fig_nums("ff_Corl-Coru",display=F)
```
![Corl-Coru vs. Distance plot for aphid-firstflight showing upper tail dependence](./Results/stat_results/stat_aphid_ff/Sp_11_Corl-Coru_vs_D.pdf){ width=50%, height=50% }

```{r ff_Pl-Pu,echo=F}
fig_nums("ff_Pl-Pu",display=F)
```
![Pl-Pu vs. Distance plot for aphid-firstflight showing upper tail dependence](./Results/stat_results/stat_aphid_ff/Sp_11_Pl-Pu_vs_D.pdf){ width=50%, height=50% }

```{r ff_D2u-D2l,echo=F}
fig_nums("ff_D2u-D2l",display=F)
```
![D2u-D2l vs. Distance plot for aphid-firstflight showing upper tail dependence](./Results/stat_results/stat_aphid_ff/Sp_11_D2u-D2l_vs_D.pdf){ width=50%, height=50% }

## North sea plankton data

<!--Shya to edit the prentation below to make it more parallel to the presentation of the model selection results for C/N data above-->

### Model selection approach

```{r read_plankton_north_sea_data, echo=F}
d0_plankton_north_sea<-as.matrix(read.csv("./Data/Plankton_North_Sea_data/planktontimeseries201117_4.csv",header=F))
data_plankton_north_sea<-d_allsp_data_plankton_north_sea(d0_plankton_north_sea)
``` 

```{r RES_plankton_north_sea, echo=F, cache=T, cache.extra=list(seed,data_plankton_north_sea)}
set.seed(seed)
#cat(paste("start-time: ",Sys.time(),"\n")) 
RES_plankton_north_sea<-RES_single_sp(d_allsp=data_plankton_north_sea,sp=16,families=c(1,3:10,13,14,16:20),level=0.05,data_pt_thrs=45)
#cat(paste("stop-time: ",Sys.time(),"\n"))    
resloc<-"./Results/fitting_results/"
saveRDS(RES_plankton_north_sea,paste(resloc,file="Plankton_North_Sea_CopulaFit_selecloc_species_16.RDS",sep=""))
```

```{r read_RES_plankton_north_sea,echo=F}
RES_plankton_north_sea<-readRDS("./Results/fitting_results/Plankton_North_Sea_CopulaFit_selecloc_species_16.RDS")
```

\newpage

```{r pns_bestcop,echo=F,results="asis"}
#library(pander)
#pander(best_cop_LTdep, caption = "Hello caption!")
# alternatively,
#pandoc.table(RES_plankton_north_sea$info_ord_AICw[,,1], caption="Plankton_north_sea : AICw for best fit copula family for each selective location pair")
#cat("\n\n\\pagebreak\n")

table_nums("pns_bestcop",display=F)
knitr::kable(RES_plankton_north_sea$info_ord_copname[,,1], caption = "Plankton_north_sea : Best fit copula family for each selective location pair")
```

```{r pns_AICw,echo=F,results="asis"}
table_nums("pns_AICw",display=F)
knitr::kable(round(RES_plankton_north_sea$info_ord_AICw[,,1],3), caption = "Plankton_north_sea : AICw for best fit copula family for each selective location pair")
```

\newpage

```{r pns_LTdep,echo=F,results="asis"}
#cat("\n\n\\pagebreak\n")

table_nums("pns_LTdep",display=F)
knitr::kable(round(RES_plankton_north_sea$info_ord_LTdep[,,1],3), caption = "Plankton_north_sea : Lower Tail dependence for best fit copula family for each selective location pair")
```

```{r pns_UTdep,echo=F,results="asis"}
table_nums("pns_UTdep",display=F)
knitr::kable(round(RES_plankton_north_sea$info_ord_UTdep[,,1],3), caption = "Plankton_north_sea : Upper Tail dependence for best fit copula family for each selective location pair")
```

\newpage

```{r pns_LTdep_AICw,echo=F,results="asis"}
#cat("\n\n\\pagebreak\n")

table_nums("pns_LTdep_AICw",display=F)
knitr::kable(round(RES_plankton_north_sea$LTdep_AICw,3), caption = "Plankton_north_sea : Lower Tail dependence statistic for best fit copula family for each selective location pair")
```

```{r pns_UTdep_AICw,echo=F,results="asis"}
table_nums("pns_UTdep_AICw",display=F)
knitr::kable(round(RES_plankton_north_sea$UTdep_AICw,3), caption = "Plankton_north_sea : Upper Tail dependence statistic for best fit copula family for each selective location pair")
```

\newpage

```{r pns_LTmUT,echo=F,results="asis"}
#cat("\n\n\\pagebreak\n")

table_nums("pns_LTmUT",display=F)
knitr::kable(round(RES_plankton_north_sea$LTdep_AICw-RES_plankton_north_sea$UTdep_AICw,3), caption = "Plankton_north_sea : Lower Tail - Upper Tail dependence statistic for best fit copula family for each of the selective location pair")
```

```{r pns_p_CvM,echo=F,results="asis"}
table_nums("pns_p_CvM",display=F)
knitr::kable(round(RES_plankton_north_sea$gfc_p_CvM,3), caption = "Plankton_north_sea : p-values (Cramer-von Mises-based test) for lowest AIC based best fit copula")
```

\newpage

```{r pns_p_KS,echo=F,results="asis"}
#cat("\n\n\\pagebreak\n")

table_nums("pns_p_KS",display=F)
knitr::kable(round(RES_plankton_north_sea$gfc_p_KS,3), caption = "Plankton_north_sea : p-values (Kolmogorov-Smirnov-based test) for lowest AIC based best fit copula")
```

`r table_nums("pns_bestcop",display="c")` shows that several copulas are much better supported than the Gaussian copula, answering the first part of question 1 for these data.
The model-averaged (using AIC) lower-tail dependence statistic and the model-averaged (again, AIC based) upper-tail dependence statistic are presented in   `r table_nums("pns_LTdep_AICw",display="c")` and `r table_nums("pns_UTdep_AICw",display="c")` respectively, and these values are distinct from what a Gaussian copula would give (i.e., 0), answering the second part of question 1 for these data. Furthermore, the difference of these two quantities (lower minus upper) in `r table_nums("pns_LTmUT",display="c")` indicates it is different from 0 for most of the locations, answering the third part of question 1. 

These results do convincingly show non-Gaussian copula structure, having `r sum((RES_plankton_north_sea$LTdep_AICw-RES_plankton_north_sea$UTdep_AICw)>0,na.rm=T)` out of `r (dim(RES_plankton_north_sea$gfc_p_CvM)[1]^2-dim(RES_plankton_north_sea$gfc_p_CvM)[1])-RES_plankton_north_sea$num_indep_loc_pair` location pair more lower tail dependence. Our fitting results are supported by the lowest-AIC copula *p*-value in the Cramer-von Mises-based test [`r table_nums("pns_p_CvM",display="c")`] of the goodness of its fit, and in the Kolmogorov-Smirnov-based test [`r table_nums("pns_p_KS",display="c")`] of the goodness of fit.

### Non-paramtric analysis of tail dependence
```{r stat_plankton_north_sea, echo=F, cache=T, cache.extra=list(seed,data_plankton_north_sea)}
set.seed(seed)
resloc<-"./Results/stat_results/stat_plankton_north_sea/"

sp<-16
good_loc<-good_loclist(d_allsp=data_plankton_north_sea,sp=sp,data_pt_thrs=45)
longs<-read.csv("./Data/Plankton_North_Sea_data/boxcornerlongs201117.csv",header=F)
lats<-read.csv("./Data/Plankton_North_Sea_data/boxcornerlats201117.csv",header=F)
longs<-longs[[1]] 
lats<-lats[[1]]

stat_plankton_north_sea<-multcall(d_allsp=data_plankton_north_sea,sp=sp,lats=lats,longs=longs,pfname=paste(resloc,"Sp_",sp,sep=''),good_loc=good_loc) 
saveRDS(stat_plankton_north_sea,paste(resloc,file="stat_plankton_north_sea_sp_16.RDS",sep=''))
```

```{r read_stat_plankton_north_sea,echo=F}
stat_plankton_north_sea<-readRDS("./Results/stat_results/stat_plankton_north_sea/stat_plankton_north_sea_sp_16.RDS")
```

```{r pns_resamp,echo=F,results="asis"}
table_nums("count_resamp",display=F)
knitr::kable(stat_plankton_north_sea$numericdf, caption = "Plankton_north_sea : resampling result for stat indicating lower tail dependence")
```

```{r pns_allcop,echo=F}
fig_nums("pns_allcop",display=F)
```
![copula plot for Plankton_north_sea](./Results/stat_results/stat_plankton_north_sea/Sp_16_AllCops.pdf)

```{r pns_spear,echo=F}
fig_nums("pns_spear",display=F)
```
![Plot for Plankton_north_sea : Spearman vs. Distance](./Results/stat_results/stat_plankton_north_sea/Sp_16_Spearman_vs_D.pdf){ width=50%, height=50% }

```{r pns_kend,echo=F}
fig_nums("pns_kend",display=F)
```
![Plot for Plankton_north_sea : Kendall vs. Distance](./Results/stat_results/stat_plankton_north_sea/Sp_16_Kendall_vs_D.pdf){ width=50%, height=50% }

```{r pns_Corl-Coru,echo=F}
fig_nums("pns_Corl-Coru",display=F)
```
![Corl-Coru vs. Distance plot for Plankton_north_sea showing lower tail dependence](./Results/stat_results/stat_plankton_north_sea/Sp_16_Corl-Coru_vs_D.pdf){ width=50%, height=50% }

```{r pns_Pl-Pu,echo=F}
fig_nums("pns_Pl-Pu",display=F)
```
![Pl-Pu vs. Distance plot for Plankton_north_sea showing lower tail dependence](./Results/stat_results/stat_plankton_north_sea/Sp_16_Pl-Pu_vs_D.pdf){ width=50%, height=50% }

```{r pns_D2u-D2l,echo=F}
fig_nums("pns_D2u-D2l",display=F)
```
![D2u-D2l vs. Distance plot for Plankton_north_sea showing lower tail dependence](./Results/stat_results/stat_plankton_north_sea/Sp_16_D2u-D2l_vs_D.pdf){ width=50%, height=50% }

# Question 2 analyses for each dataset

# Question 3 analyses for each dataset

Recall question 3 is: What are the consequences of non-Gaussian copula structure and tail dependence for our understanding of biology and for applications?

## Aphid count

<!--Shya to add results about skewness of spatial means-->
```{r skewness_count_plot, echo=F, cache=T, cache.extra=list(seed,mtime("ncsurrog.R"),mtime("skewness_multivar_dataset.R"))}
set.seed(seed)
pdf("./Results/skewness_results/skewness_aphid_count/skewness_aphid_count_sp_10.pdf")
par(mfrow=c(2,1))
numsurrog<-10000
loclist<-good_loclist(d_allsp=data_aphid_count,sp=10,data_pt_thrs=30)
answer1k<-skewness_testing(ts_matrix=sp_data(sp=10,d_allsp=data_aphid_count),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="kendall") 

p_left<-sum(answer1k$surrogskw < answer1k$realskw)/numsurrog

mtext(paste0("(A) result based on kendall preserving normal surrogates, p = ",p_left),side=3,line=0.2,col="navyblue")

answer1s<-skewness_testing(ts_matrix=sp_data(sp=10,d_allsp=data_aphid_count),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="spearman") 

p_left<-sum(answer1s$surrogskw < answer1s$realskw)/numsurrog

mtext(paste0("(B) result based on spearman preserving normal surrogates , p = ",p_left),side=3,line=0.2,col="navyblue")


dev.off()
```

```{r skewness_count,echo=F}
fig_nums("skewness_count",display=F)
```
![Skewness_count for species : Green spruce aphid](./Results/skewness_results/skewness_aphid_count/skewness_aphid_count_sp_10.pdf){ width=50%, height=50% }


## Aphid first flight

<!--Shya to add results about skewness of spatial means-->
```{r skewness_ff_plot, echo=F, cache=T, cache.extra=list(seed,mtime("ncsurrog.R"),mtime("skewness_multivar_dataset.R"))}
set.seed(seed)
pdf("./Results/skewness_results/skewness_aphid_ff/skewness_aphid_ff_sp_11.pdf")
par(mfrow=c(2,1))
numsurrog<-10000
loclist<-good_loclist(d_allsp=data_aphid_ff,sp=11,data_pt_thrs=30)

answer2k<-skewness_testing(ts_matrix=sp_data(sp=11,d_allsp=data_aphid_ff),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="kendall") 
p_right<-sum(answer2k$surrogskw > answer2k$realskw)/numsurrog
mtext(paste0("(A) result based on kendall preserving normal surrogates, p = ",p_right),side=3,line=0.2,col="navyblue")

answer2s<-skewness_testing(ts_matrix=sp_data(sp=11,d_allsp=data_aphid_ff),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="spearman") 
p_right<-sum(answer2s$surrogskw > answer2s$realskw)/numsurrog
mtext(paste0("(B) result based on spearman preserving normal surrogates , p = ",p_right),side=3,line=0.2,col="navyblue")

dev.off()
```

```{r skewness_ff,echo=F}
fig_nums("skewness_ff",display=F)
```
![Skewness_firstflight for species : Leaf-curling plum aphid](./Results/skewness_results/skewness_aphid_ff/skewness_aphid_ff_sp_11.pdf){ width=50%, height=50% }

## North Sea plankton

<!--Shya to add results about skewness of spatial means-->
<!--Shya to add results about skewness of spatial means-->
```{r skewness_pns_plot, echo=F, cache=T, cache.extra=list(seed,mtime("ncsurrog.R"),mtime("skewness_multivar_dataset.R"))}
set.seed(seed)
pdf("./Results/skewness_results/skewness_plankton_north_sea/skewness_plankton_north_sea_sp_16.pdf")
par(mfrow=c(2,1))
numsurrog<-10000
loclist<-good_loclist(d_allsp=data_plankton_north_sea,sp=16,data_pt_thrs=45)
answer3k<-skewness_testing(ts_matrix=sp_data(sp=16,d_allsp=data_plankton_north_sea),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="kendall") 

p_left<-sum(answer3k$surrogskw < answer3k$realskw)/numsurrog

mtext(paste0("(A) result based on kendall preserving normal surrogates, p = ",p_left),side=3,line=0.2,col="navyblue")

answer3s<-skewness_testing(ts_matrix=sp_data(sp=16,d_allsp=data_plankton_north_sea),loclist=loclist,numsurrog=numsurrog,ploton=T,
                          corpres="spearman") 

p_left<-sum(answer3s$surrogskw < answer3s$realskw)/numsurrog

mtext(paste0("(B) result based on spearman preserving normal surrogates , p = ",p_left),side=3,line=0.2,col="navyblue")

dev.off()
```

```{r skewness_pns,echo=F}
fig_nums("skewness_pns",display=F)
```
![Skewness_plankton_north_sea for species : Ceratium_furca](./Results/skewness_results/skewness_plankton_north_sea/skewness_plankton_north_sea_sp_16.pdf){ width=50%, height=50% }
